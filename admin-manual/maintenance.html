
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>&lt;no title&gt; &#8212; ecs-admin-manual 2020-05-31@15:25 documentation</title>
    <link rel="stylesheet" href="_static/better.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
      <link rel="stylesheet" href="static/custom.css" type="text/css" />
  </head><body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>## Maintenance</p>
<p>### Reconfigure a running Appliance</p>
<ul class="simple">
<li><p>edit /app/env.yml</p></li>
<li><dl class="simple">
<dt>optional, build new env package:</dt><dd><ul>
<li><p>first time requisites install, call <cite>env-package.sh –requirements</cite></p></li>
<li><p>build new env package call <cite>env-package.sh /app/env.yml</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>activate changes into current environment, call <cite>env-update.sh</cite></p></li>
<li><p>restart and apply new environment: <cite>systemctl restart appliance</cite></p></li>
</ul>
<p>### Start, Stop, Update Appliance</p>
<ul class="simple">
<li><p>Start appliance: <cite>systemctl start appliance</cite></p></li>
<li><p>Stop appliance: <cite>systemctl stop appliance</cite></p></li>
<li><p>Update Appliance (appliance and ecs): <cite>systemctl start appliance-update</cite></p></li>
</ul>
<p>### Recover from failed state</p>
<p>if the appliance.service enters fail state, it creates a file named
“/run/appliance_failed”.</p>
<p>After resolving the issue, remove this file using <cite>rm /run/appliance_failed</cite>
before restarting the service using <cite>systemctl restart appliance</cite>.</p>
<p>If the issue was within the ecs-appliance sourcecode, re-run an appliance update:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">rm</span> <span class="pre">/run/appliance-failed</span>
<span class="pre">touch</span> <span class="pre">/app/etc/flags/force.update.appliance</span>
<span class="pre">systemctl</span> <span class="pre">restart</span> <span class="pre">appliance-update</span>
<span class="pre">`</span></code></p>
<p>### Desaster Recovery from backup</p>
<ul class="simple">
<li><p>install a new unconfigured appliance as described in chapter install</p></li>
<li><p>copy old saved env.yml to new target machine at /app/env.yml</p></li>
<li><p>reboot new target machine, appliance will configure but stop because of empty database</p></li>
<li><p>ssh into new target machine, execute <cite>recover-from-backup.sh –yes-i-am-sure</cite></p></li>
</ul>
<p>### Automatic Updates</p>
<p>Updates are scheduled depending appliance:update:oncalendar once per day at 06:30 per default.</p>
<p>Depending the types of updates available the update will take between 1 and 5 minutes in most cases, 5-10 minutes if the ecs container will be rebuild and up to 30 minutes if there are database migrations to be executed.</p>
<p>The following items are updated:
+ appliance source will be updated and executed
+ all system packages are updated, special precautions are taken for docker, postgresql and the kernel including a reboot if needed
+ lets encrypt certificates are updated
+ ecs source will be updated and rebuild</p>
<blockquote>
<div><ul class="simple">
<li><p>the ecs-docs source will be updated</p></li>
<li><p>the corresponding support container will be updated</p></li>
<li><p>database migrations will be executed (including a dump before doing so)</p></li>
</ul>
</div></blockquote>
<p><strong>Warning</strong>: Automatic updates are intended to run with Metric and Alert support, so you will get alerts to react and can investigate using the Metric Server to find the root cause. <strong>If you do not make metric recording and alerting, we recommend updating only manual.</strong> To do this, enter “False” under appliance:update:automatic in the file env.yml. For a manual update run call <cite>systemctl start appliance-update</cite></p>
<p>### Backup Configuration</p>
<ul class="simple">
<li><p>Backup is done using duplicity, see [Duplicity Manual](<a class="reference external" href="http://duplicity.nongnu.org/duplicity.1.html">http://duplicity.nongnu.org/duplicity.1.html</a>) and [duply](<a class="reference external" href="http://duply.net/wiki/index.php/Duply-documentation">http://duply.net/wiki/index.php/Duply-documentation</a>)</p></li>
<li><p>Cycle: Backup is done once per day around 00:30</p></li>
<li><p>Safety Measures for backup:
+ Database must exist
+ Storage-Vault must not be empty</p></li>
<li><p>Contents:
+ /data/ecs-storage-vault: All uploaded and all created documents
+ /data/ecs-pgdump: Current database dump</p></li>
<li><dl class="simple">
<dt>Type, Rotation &amp; Retention:</dt><dd><ul>
<li><p>Backup will start with a full backup and do incremental backups afterwards</p></li>
<li><p>2 Months after the first full backup a second full backup will be created</p></li>
<li><p>Rotation: Every Backup (full or incremental) will be purged after 4 Months</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>#### Extra Configuration needed for scp/sftp backup (ssh)</p>
<p>if appliance:backup:url is using either scp or sftp (preferred):</p>
<ul class="simple">
<li><p>add ssh host entry in /root/.ssh/known_hosts for duplicity to connect to the ssh server</p></li>
<li><p>create this entry by executing: <cite>duply /root/.duply/appliance-backup status</cite></p></li>
<li><p>add this key to env.yml as extra:state:</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a>`
appliance:</p>
<blockquote>
<div><dl class="simple">
<dt>extra:</dt><dd><dl class="simple">
<dt>states: |</dt><dd><dl class="simple">
<dt>sftp_server_hostkey_into_known_hosts:</dt><dd><dl class="simple">
<dt>file.append:</dt><dd><ul class="simple">
<li><p>name: /root/.ssh/known_hosts</p></li>
<li><p>makedirs: true</p></li>
<li><dl class="simple">
<dt>text: |</dt><dd><p>[1.2.3.4]:12345 ssh-rsa XXXHOSTKEYXXX</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p><a href="#id3"><span class="problematic" id="id4">``</span></a><a href="#id5"><span class="problematic" id="id6">`</span></a></p>
<p>### Logging Configuration</p>
<p>Container:
+ all container log to stdout and stderr
+ docker has the logs of every container available</p>
<blockquote>
<div><ul class="simple">
<li><p>look at a log stream using eg. <cite>docker logs ecs_ecs.web_1</cite></p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>journald will get the container logs via the appliance.service which calls docker-compose</dt><dd><ul>
<li><p>this includes backend nginx, uwsgi, beat, worker, smtpd, redis, memcached, pdfas, mocca</p></li>
<li><p>to follow use <cite>journalctl -u appliance -f</cite></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Host:
+ all logging (except postgres) is going through journald
+ follow whole journal: <cite>journalctl -f</cite>
+ only follow service, eg. prepare-appliance: <cite>journalctl -u prepare-appliance -f</cite>
+ follow frontend nginx: <cite>journalctl -u nginx -f</cite>
+ search for salt-call output: <cite>journalctl $(which salt-call)</cite></p>
<p>### Metrics Collection</p>
<ul>
<li><dl>
<dt>if <cite>appliance:metric:exporter</cite> is set, metrics are exported from the subsystems</dt><dd><ul>
<li><dl>
<dt>export metrics of:</dt><dd><p>frontend nginx, redis, memcached, uwsgi, cadvisor,
process details(uwsgi, postgres, nginx, celery),
prometheus node(diskstats, entropy, filefd, filesystem, hwmon, loadavg,</p>
<blockquote>
<div><p>mdadm, meminfo, netdev, netstat, stat, textfile, time, uname, vmstat)</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><p>additional service metrics from: appliance-backup, appliance-update</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>if <cite>appliance:metric:server</cite> is set, these exported metrics are collected and</dt><dd><p>stored by a prometheus server and alerts are issued using email to root
using the prometheus alert server
+ there are alerts for: NodeRebootsTooOften, NodeFilesystemFree, NodeMemoryUsageHigh, NodeLoadHigh, a.o.</p>
<blockquote>
<div><ul class="simple">
<li><p>for a detailed alert list look at the [alert.rules.yml sourcefile](<a class="reference external" href="https://github.com/ecs-org/ecs-appliance/blob/master/salt/appliance/metric/alert.rules.yml">https://github.com/ecs-org/ecs-appliance/blob/master/salt/appliance/metric/alert.rules.yml</a>)</p></li>
<li><p>to <strong>add custom rules create rules</strong> files in the config yaml using “file:<em>:contents” with a path of “/app/etc/prometheus-rules.d/</em>.rules.yml”</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>the prometheus gui is at [<a class="reference external" href="http://172.17.0.1:9090](http://172.17.0.1:9090">http://172.17.0.1:9090](http://172.17.0.1:9090</a>)</p></li>
<li><p>the prometheus alert gui is at [<a class="reference external" href="http://172.17.0.1:9093](http://172.17.0.1:9093">http://172.17.0.1:9093](http://172.17.0.1:9093</a>)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if <cite>appliance:metric:gui</cite> is set, a grafana server is started to display the collected metrics</dt><dd><ul class="simple">
<li><p>grafana is available at [<a class="reference external" href="http://localhost:3000](http://localhost:3000">http://localhost:3000](http://localhost:3000</a>)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>if <cite>appliance:metric:pghero</cite> is set, start a pghero instance for postgres inspection</dt><dd><ul class="simple">
<li><p>pghero is avaiable at [<a class="reference external" href="http://localhost:5081](http://localhost:5081">http://localhost:5081](http://localhost:5081</a>)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Use ssh port forwarding to access these ports, eg. for 172.17.0.1:9090 use <cite>ssh root&#64;hostname -L 9090:172.17.0.1:9090</cite></p>
<p>### Alerting Setup</p>
<p>if <cite>ecs:settings[“SENTRY_DSN”]</cite> and <cite>appliance:sentry:dsn</cite> are defined,
the appliance will report the following items to sentry:</p>
<ul class="simple">
<li><p>python exceptions in web, worker, beat, smtpd</p></li>
<li><p>salt-call exceptions and state returns with error states</p></li>
<li><p>systemd service exceptions where appliance-failed or service-failed is triggered</p></li>
<li><p>shell calls to appliance.include: appliance_failed, appliance_exit, sentry_entry</p></li>
<li><p>internal mails to root, eg. prometheus alerts</p></li>
</ul>
<p>### Email Challenges</p>
<p>#### Mail send from ECS to Emailserver doing greylisting</p>
<p>Issue:
Emails send from the appliance to a target mailserver that does greylisting will always be delayed.</p>
<p>Resolution:
To remove those delays, the greylisting whitelist of the target mailserver has to be extended with the domain of the ecs appliance.</p>
<p>Technical Background:
The appliance always uses a new unique email address for each outgoing mail (beside registration) and greylisting always delays the first email from an email address.</p>
<p>### Maintenance commands in a running ecs container
for most ecs commands it is not important to which instance (web,worker)
you connect to, “ecs_ecs.web_1” is used as example.</p>
<ul class="simple">
<li><p>image = ecs, mocca, pdfas, memcached, redis</p></li>
<li><p>ecs.startcommand = web, worker, beat, smtpd</p></li>
<li><dl class="simple">
<dt>as root <cite>docker exec -it ecs_image[.startcommand]_1 /path/to/command</cite></dt><dd><ul>
<li><p>eg. <cite>docker exec -it ecs_ecs.web_1 /bin/bash</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>shell as app user with activated environment</dt><dd><ul>
<li><p><cite>docker exec -it ecs_ecs.web_1 /start run /bin/bash</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>manualy create a celery task:</dt><dd><ul>
<li><p><cite>docker exec -it ecs_ecs.web_1 /start run celery –serializer=pickle -A ecs call ecs.integration.tasks.clearsessions</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>celery events console</dt><dd><ul>
<li><p><cite>docker exec -it ecs_ecs.web_1 /start run /bin/bash -c “TERM=screen celery -A ecs events”</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>enter a django shell_plus as app user in a running container</dt><dd><ul>
<li><p><cite>docker exec -it ecs_ecs.web_1 /start run ./manage.py shell_plus</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>generate all workflow graphs</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">docker</span> <span class="pre">exec</span> <span class="pre">-it</span> <span class="pre">ecs_ecs.web_1</span> <span class="pre">/start</span> <span class="pre">run</span> <span class="pre">/bin/bash</span>
<span class="pre">./manage.py</span> <span class="pre">workflow_dot</span> <span class="pre">core.submission</span> <span class="pre">|</span> <span class="pre">dot</span> <span class="pre">-Tpng</span> <span class="pre">-osubmission.png</span>
<span class="pre">./manage.py</span> <span class="pre">workflow_dot</span> <span class="pre">notifications.notification</span> <span class="pre">|</span> <span class="pre">dot</span> <span class="pre">-Tpng</span> <span class="pre">-onotification.png</span>
<span class="pre">./manage.py</span> <span class="pre">workflow_dot</span> <span class="pre">votes.vote</span> <span class="pre">|</span> <span class="pre">dot</span> <span class="pre">-Tpng</span> <span class="pre">-ovote.png</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><p>generate ECX-Format Documentation</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">docker</span> <span class="pre">exec</span> <span class="pre">-it</span> <span class="pre">ecs_ecs.web_1</span> <span class="pre">/start</span> <span class="pre">run</span> <span class="pre">/bin/bash</span>
<span class="pre">./manage.py</span> <span class="pre">ecx_format</span> <span class="pre">-t</span> <span class="pre">html</span> <span class="pre">-o</span> <span class="pre">ecx-format.html</span>
<span class="pre">./manage.py</span> <span class="pre">ecx_format</span> <span class="pre">-t</span> <span class="pre">pdf</span> <span class="pre">-o</span> <span class="pre">ecx-format.pdf</span>
<span class="pre">`</span></code></p>
<p>### Maintenance commands for the appliance host</p>
<p>All snippets expect root.</p>
<ul class="simple">
<li><p>destroy and recreate database:</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">gosu</span> <span class="pre">app</span> <span class="pre">dropdb</span> <span class="pre">ecs</span>
<span class="pre">gosu</span> <span class="pre">postgres</span> <span class="pre">createdb</span> <span class="pre">ecs</span> <span class="pre">-T</span> <span class="pre">template0</span> <span class="pre">-l</span> <span class="pre">de_DE.utf8</span>
<span class="pre">rm</span> <span class="pre">/app/etc/tags/last_running_ecs</span>
<span class="pre">systemctl</span> <span class="pre">restart</span> <span class="pre">appliance</span>
<span class="pre">`</span></code></p>
<ul>
<li><dl class="simple">
<dt>get latest dump from backup to /root/ecs.pgdump.gz:</dt><dd><ul class="simple">
<li><p><cite>duply /root/.duply/appliance-backup fetch ecs-pgdump/ecs.pgdump.gz /root/ecs.pgdump.gz</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>quick update appliance code:</dt><dd><ul class="simple">
<li><p><cite>cd /app/appliance; gosu app git pull; salt-call state.highstate pillar=’{“appliance”:{“enabled”:true}}’ 2&gt;&amp;1; rm /var/www/html/503.html</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>check which system packages are available for update:</dt><dd><ul class="simple">
<li><p><cite>/usr/lib/update-notifier/apt-check -p</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>cleanup last activity stamps for unattended upgrades, so unattended-upgrades will do all activity again</dt><dd><ul class="simple">
<li><p><cite>touch /app/etc/flags/force.update.system</cite> before <cite>systemctl start appliance-update</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>list active systemd timer: <cite>systemctl list-timers –all</cite></p></li>
<li><p>display systemd service change: <cite>journalctl -m _PID=1 -f</cite></p></li>
<li><p>manual run letsencrypt client (do not call as root): <cite>gosu app dehydrated –help</cite></p></li>
<li><dl class="simple">
<dt>display revoked certificates serials:</dt><dd><ul class="simple">
<li><p><cite>openssl crl -inform PEM -text -noout -in /app/etc/crl.pem</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>get cummulative cpu,mem,net,disk statistics of container:</dt><dd><ul class="simple">
<li><p><cite>docker stats $(docker ps|grep -v “NAMES”|awk ‘{ print $NF }’|tr “n” ” “)</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>read details of a container in yaml:</dt><dd><ul class="simple">
<li><p><cite>docker inspect 1b17069fe3ba | python -c ‘import sys, yaml, json; yaml.safe_dump(json.load(sys.stdin), sys.stdout, default_flow_style=False)’ | less</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>activate /run/active-env.yml in current shell of appliance vm:</dt><dd><ul class="simple">
<li><p><cite>. /usr/local/share/appliance/env.include; ENV_YML=/run/active-env.yml userdata_to_env ecs,appliance</cite></p></li>
<li><p>to also set <a href="#id7"><span class="problematic" id="id8">*</span></a>GIT_SOURCE defaults: <cite>. /usr/local/share/appliance/appliance.include</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>send sentry test entry:</p>
<blockquote>
<div><ul class="simple">
<li><p>using bash and ravencat.py</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">.</span> <span class="pre">/usr/local/share/appliance/env.include;</span> <span class="pre">.</span> <span class="pre">/usr/local/share/appliance/appliance.include;</span> <span class="pre">ENV_YML=/run/active-env.yml</span> <span class="pre">userdata_to_env</span> <span class="pre">ecs,appliance;</span> <span class="pre">sentry_entry</span> <span class="pre">&quot;test&quot;</span> <span class="pre">&quot;Test</span> <span class="pre">Message</span> <span class="pre">$(hostname</span> <span class="pre">-f)&quot;</span>
<span class="pre">`</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p>using a django management command</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">docker</span> <span class="pre">exec</span> <span class="pre">-it</span> <span class="pre">ecs_ecs.web_1</span> <span class="pre">/start</span> <span class="pre">run</span> <span class="pre">/bin/bash</span>
<span class="pre">./manage.py</span> <span class="pre">raven</span> <span class="pre">test</span>
<span class="pre">`</span></code></p>
<ul class="simple">
<li><dl class="simple">
<dt>most time spent in state.highstate:</dt><dd><ul>
<li><p><cite>journalctl -u appliance-update | grep -B 5 -E “Duration: [0-9]{3,5}.”</cite></p></li>
<li><p><cite>journalctl -u appliance-update | grep “ID:” -A6 | grep -E “(ID:|Function:|Duration:)” | sed -r “s/.*(ID:|Function:|Duration)(.*)/1 2/g” | paste -s -d ‘  n’  - | sed -r “s/ID: +([^ ]+) Function: +([^ ]+) Duration : ([^ ]+ ms)/3 2 1/g” |sort -n</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>check send emails from postfix</dt><dd><ul>
<li><p><cite>for a in sent deferred bounced; do echo “#### $a”; journalctl -u postfix | grep “status=$a” | awk ‘{print $7}’ | sed ‘s/to=&lt;//g’ | sed ‘s/&gt;,//g’ | sort -n; done</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>check for incoming or outgoing smtp from ecs</dt><dd><ul>
<li><p><cite>journalctl -u appliance –since “2019-07-27” | grep -Ei “ecs.(worker_1|smtpd_1).+(Accepted email|Rejected email|Forward |Forwarding|Not forwarding|email raised exception|Invalid message format|Relay access denied)”  | sed -r “s/([^ ]+ [^ ]+ [0-9:]+ ).*ecs.communication.tasks.forward_messages[[0-9a-f-]+]:(.*)/12/g” | sed -r “s/([^ ]+ [^ ]+ [0-9:]+ ).+ecs.smtpd_1.+INFO (.*)/1 2/g”</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ip adress config</dt><dd><ul>
<li><p><cite>ip -o addr show | grep -Ev “veth[0-9a-f]{7}”; default_iface=$(awk ‘$2 == 00000000 { print $1 }’ /proc/net/route); default_ip=$(ip addr show dev “$default_iface” | awk ‘$1 == “inet” { sub(“/.*”, “”, $2); print $2 }’); echo “Default Interface: $default_iface , Default IP: $default_ip</cite></p></li>
</ul>
</dd>
</dl>
</li>
</ul>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<form class="search" action="search.html" method="get">
  <input type="text" name="q"
   placeholder="type to search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="related bottom">
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
  <nav id="breadcrumbs">
    <ul>
      <li><a href="index.html">ecs-admin-manual 2020-05-31@15:25 documentation</a></li> 
    </ul>
  </nav>
  </div>
  <footer id="pagefooter">&copy; Copyright 2020 Medizinische Universität Wien, Medizinische Universität Innsbruck, Medizinische Universität Graz, Johannes Kepler Universität Linz, Karl Landsteiner Privatuniversität für Gesundheitswissenschaften, Land Salzburg.

  </footer>

  
  </body>
</html>